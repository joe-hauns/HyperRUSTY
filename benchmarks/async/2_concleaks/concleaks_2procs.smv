MODULE main
VAR
    -- globals (unchanged)
    in_HIGH : boolean;    -- in_HIGH-value
    LOW     : boolean;    -- low-value
    var_X   : boolean;    -- X
    var_Y   : boolean;    -- Y

    SCHEDULE : 0..1;      -- 0: p1 moves, 1: p2 moves

    halt : boolean;

    -- flattened state for proc1: programs(ID_one, SCHEDULE, LOW, in_HIGH, var_X, var_Y, 0)
    proc1_line       : 0..8;
    proc1_loop_count : 0..2;

    -- flattened state for proc2: programs(ID_two, SCHEDULE, LOW, in_HIGH, var_X, var_Y, 6)
    proc2_line       : 0..8;
    proc2_loop_count : 0..2;

    obs_X_is_zero : boolean;  -- observable: X==0
    obs_X_is_one  : boolean;  -- observable: X==1
    obs_Y_is_zero : boolean;  -- observable: Y==0
    obs_Y_is_one  : boolean;  -- observable: Y==1
    

ASSIGN

    init(obs_X_is_zer0) := FALSE;
    next(obs_X_is_zero) :=
        case 
            ((proc2_line = 7) & (!(in_HIGH))): TRUE;
            TRUE                             : obs_X_is_zero;
        esac;   

    init(obs_X_is_one) := FALSE;
    next(obs_X_is_one) :=
        case 
            ((proc2_line = 7) & (in_HIGH)) : TRUE;
            TRUE                            : obs_X_is_one;
        esac;
    
    init(obs_Y_is_zero) := FALSE;
    next(obs_Y_is_zero) :=
        case 
            ((proc2_line = 8) & (!(in_HIGH))) : TRUE;
            TRUE                              : obs_Y_is_zero;
        esac;
    init(obs_Y_is_one) := FALSE;
    next(obs_Y_is_one) :=
        case 
            ((proc2_line = 8) & (in_HIGH)) : TRUE;
            TRUE                           : obs_Y_is_one;
        esac;

    ----------------------------------------------------------------
    -- inputs / other globals (updated references)
    ----------------------------------------------------------------
    init(in_HIGH) := {TRUE,FALSE};
    next(in_HIGH) := in_HIGH;

    init(LOW) := FALSE;
    next(LOW) := LOW;


    init(var_X) := FALSE;
    next(var_X) :=
        case
            (proc1_line = 0)              : {FALSE};
            ((proc1_line = 2) | (proc1_line = 5)) : {TRUE};
            TRUE                          : var_X;
        esac;

    init(var_Y) := FALSE;
    next(var_Y) :=
        case
            (proc1_line = 0)              : {FALSE};
            ((proc1_line = 3) | (proc1_line = 3)) : {TRUE}; -- (same as your original)
            TRUE                          : var_Y;
        esac;

    init(SCHEDULE) := {0,1};
    next(SCHEDULE) := 
        case
            (proc1_loop_count = 2) : 1;
            (proc2_loop_count = 2) : 0;
            TRUE                   : {0,1};
        esac;

    init(halt) := FALSE;
    next(halt) :=
        case
            ((proc1_loop_count = 2) & (proc2_loop_count = 2)) : TRUE;
            TRUE                                              : halt;
        esac;

    ----------------------------------------------------------------
    -- proc1: programs(ID_one, SCHEDULE, LOW, in_HIGH, var_X, var_Y, 0) — flattened
    ----------------------------------------------------------------
    init(proc1_loop_count) := 0;
    next(proc1_loop_count) :=
        case
            (proc1_loop_count = 2)                          : 2;
            ((proc1_line = 0) & (SCHEDULE = 0)) : proc1_loop_count + 1;
            ((proc1_line = 6) & (SCHEDULE = 0)) : proc1_loop_count + 1;
            TRUE                                             : proc1_loop_count;
        esac;

    init(proc1_line) := 0;
    next(proc1_line) :=
        case
            (!(SCHEDULE = 0)) : proc1_line;
            -- program1
            (proc1_line = 0)                         : {1};         -- x=0, y=0
            (proc1_line = 1 & (in_HIGH = LOW))       : {2};         -- if (h == l)
            (proc1_line = 2)                         : {3};         -- x=1
            (proc1_line = 3)                         : {0};         -- y=1
            (proc1_line = 1 & (!(in_HIGH = LOW)))    : {4};
            (proc1_line = 4)                         : {5};         -- y=1
            (proc1_line = 5)                         : {0};         -- x=1
            -- program2
            (proc1_line = 6)                         : {7};
            (proc1_line = 7)                         : {8};         -- output x
            (proc1_line = 8)                         : {6};         -- output y

            TRUE : proc1_line;
        esac;

    ----------------------------------------------------------------
    -- proc2: programs(ID_two, SCHEDULE, LOW, in_HIGH, var_X, var_Y, 6) — flattened
    ----------------------------------------------------------------
    init(proc2_loop_count) := 0;
    next(proc2_loop_count) :=
        case
            (proc2_loop_count = 2)                          : 2;
            ((proc2_line = 0) & (SCHEDULE = 1)) : (proc2_loop_count + 1);
            ((proc2_line = 6) & (SCHEDULE = 1)) : (proc2_loop_count + 1);
            TRUE                                             : proc2_loop_count;
        esac;

    init(proc2_line) := 6;
    next(proc2_line) :=
        case
            (!(SCHEDULE = 1)) : proc2_line;
            -- program1
            (proc2_line = 0)                         : {1};         -- x=0, y=0
            (proc2_line = 1 & (in_HIGH = LOW))        : {2};         -- if (h == l)
            (proc2_line = 2)                         : {3};         -- x=1
            (proc2_line = 3)                         : {0};         -- y=1
            (proc2_line = 1 & (!(in_HIGH = LOW)))    : {4};
            (proc2_line = 4)                         : {5};         -- y=1
            (proc2_line = 5)                         : {0};         -- x=1

            -- program2
            (proc2_line = 6)                         : {7};
            (proc2_line = 7)                         : {8};         -- output x
            (proc2_line = 8)                         : {6};         -- output y

            TRUE : proc2_line;
        esac;

DEFINE

    -- halting condition
    halt := ((proc1_line=8) & (proc2_line=8));